PACKAGES

Um pacote é um mecanismo para agrupar classes, interfaces e outros tipos
relacionados em um único namespace. Isso serve para organizar o código,
evitar conflitos de nomes, promover a reutilização e controlar o acesso
a elementos.

Para criar um pacote, basta clicar em cima da pasta 
'src' -> new -> package. E pronto, pacote criado.
A classe que estiver dentro do pacote, em sua primeira linha terá algo 
como: 

	ex.: package nomeDoPacote;

OBS.: Para classes com atributos "protected", podem ser acessados desde
      que sejam sub-classes da classe-PAI, mesmo que estejam em outro 
      pacote.



JAVA COLLECTIONS

"Java Collections" referem-se ao Java Collections Framework (JCF), um 
conjunto de interfaces e classes no pacote java.util que fornecem uma 
arquitetura unificada para armazenar e manipular grupos de objetos. Elas
permitem gerenciar dados de forma organizada, oferecendo estruturas como
Listas(com elementos ordenados e duplicados), Conjunto(sem duplicados) e
Mapas (pares chave-valor).

Principais tipos de Collections:

- List: Armazena uma sequência ordenada de elementos que podem incluir 
	duplicados. 

	ex.: List<String> list = new ArrayList<>();
             list.add("Bernardo");
             list.add("Anderson");
             list.add("Bernardo");
             list.add("Anderson");

	- Para pegar um valor em um "List", é pelo indice:
	
	     * list.get(0);


- Set: Representa uma coleção que não permite elementos duplicados e não
       garante a ordem dos elementos.

	ex.: Set<String> setDeStrings = new HashSet<>();
             setDeStrings.add("Anderson");
             setDeStrings.add("Bernardo");
	
	OBS.: Mesmo que eu tente adicionar um valor repetido, o set 
	      NÃO vai armazenar o valor repetido.

	- Para verificar um valor em um "Set":
	
	     * setDeStrings.contains("Bernardo");


- Queue: Armazena elementos antes de serem processados e segue o 
	 princípio FIFO (First-In, First-Out - primeiro a entrar, 
	 primeiro a sair). 

	ex.: Queue<String> queue = new LinkedList<>();
             queue.add("Anderson");
             queue.add("Bernardo");


	- Para acessar o primeiro valor em um "Queue":

	     * queue.poll();


	OBS.: O "Queue" é uma FILA. Quando eu acesso um dado em um 
	      "Queue", ele APAGA este valor, para que o proximo valor
	      vá para a primeira posição da fila.

		ex.: System.out.println("Queue: " + queue.poll());
           	     System.out.println("Queue: " + queue);

		1- Vai mostrar no terminal que o VALOR 
		   ACESSADO(queue.poll) foi: "Anderson";

		2- Vai mostrar no terminal a FILA(Queue): "Bernardo";
		   pois o valor "Anderson" foi excluido.


	- Também é possivel "Espiar" o primeiro valor da fila(Queue) sem 
	que ele seja excluido:

		* queue.peek();

		- Vai espiar qual o primeiro valor da fila, e ele 
		  permanacerá intacto, pois não houve ação nenhuma.


	- Também é possivel REMOVER o primeiro valor da fila(Queue):

		* queue.remove();

		- A única diferença deste método para o "poll" é que
		  se a fila estiver vazia, ele vai mostrar uma excessão
		  (erro) no terminal. E o "poll" iria apenas mostrar a 
		  fila vazia.
             

- Map: Armazena pares chave-valor, onde cada chave é única. 

	ex.: Map<String, String> map = new HashMap<>();
             map.put("nome", "Anderson");
             map.put("sobrenome", "Bernardo");

		* É como um OBJETO em JavaScript, ao declarar um "Map"
		  indicamos o TIPO da CHAVE e depois o TIPO do VALOR.

	Para pegar um valor em um "Map", é pelo indice:
	
	    * map.get(0);



GENERICS

É um recurso da linguagem que permite criar componentes de código 
(classes, interfaces e métodos) que podem operar em diferentes tipos de 
dados de forma segura e reutilizável, sem a necessidade de casting 
explícito.
Seria como eu criar meu próprio TIPO. Por exemplo:

	ex.: public class Pintura<MeuTipo> {...}
    
    	- Criei uma classe 'Pintura' do TIPO genérico, que eu criei.


Utilizando este tipo genérico em métodos e atributos:	

	ex.: public class Pintura<MeuTipo> {

    		private List<MeuTipo> coisasQueVouPintar;

		public void pintar(MeuTipo coisa) {
        		this.coisasQueVouPintar.add(coisa);
    		}

	     }


		1- Criei uma classe 'Pintura' do TIPO genérico;

		2- Criei um ATRIBUTO 'coisasQueVouPintar' que será uma
		   LISTA(List) do tipo genérico(MeuTipo);

		3- Criei um MÉTODO 'pintar' que recebe como parametro
		   uma coisa do tipo genérico(MeuTipo coisa).

		4- E a lista do tipo genérico 'coisasQueVouPintar' vai
		   adicionar esta 'coisa' do tipo genérico dentro dela.

	* É como se eu tivesse uma oficina de pintura(Class Pintura),
	  e eu tenho uma LISTA de coisas para pintar no 
	  dia(coisasQueVouPintar). E não importa o
	  tipo de coisa que ela é(Tipo genérico<MeuTipo>), se esta coisa
	  estiver na lista eu vou pintar esta coisa. 



RECORDS

Records são uma nova forma de declarar classes. São tipos de dados 
imutáveis, projetados para representar valores de forma mais concisa, 
simplificando a criação de classes que atuam como recipientes de dados. 
Records reduzem a verbosidade do código ao gerar automaticamente métodos
como construtores, getters (métodos de acesso), equals(), hashCode() e 
toString(), baseados nos campos declarados. 

	ex.: public record Carro2(String modelo, String cor, int ano) {
	     }

	- Diferentes das CLASSES, nos RECORDS colocamos os atributos 
	  dentro dos parenteses '(...)' e o JAVA vai gerar todos os 
	  métodos necessários para estes dados. As chaves '{}' são só
	  por questão de sintaxe, mas elas não recebem dados.



STREAM API

É um recurso que permite o processamento declarativo e funcional de 
coleções de dados, como listas e arrays. Em vez de usar loops 
tradicionais, você define operações de agregação como filtrar, mapear e 
reduzir, deixando o controle de fluxo para a própria API e focando na 
lógica de negócio. Isso resulta em código mais legível, conciso e 
produtivo, especialmente ao lidar com grandes conjuntos de dados. 

	ex.: list.stream()

	- Assim transformamos a lista chamada 'list' em uma STREAM API.

OBS.: TEMOS QUE TER EM MENTE que sempre que transformarmos uma estrutura
      de dados em uma STREAM API ela não será mais uma estrutura de 
      dados. SE QUISERMOS QUE ELA VOLTE A SER UMA ESTRUTURA DE DADOS é
      necessário transformar ela DEVOLTA.

	ex.: List<String> Andersons = list.stream() ... .toList();

	- Transformou a 'list' em uma LISTA novamente com o método:
	  '.toList()'.

TIPOS DE OPERAÇÕES COM STREAM API:

   * .filter() :

	ex.: List<String> Andersons = list.stream().filter(nome -> 
		nome.startsWith("Anderson")).toList();

	EXPLICAÇÃO:

	1- List<String> Andersons : Criei uma lista do tipo String 
				    chamada 'Andersons';
	
	2- list.stream() : transformei a lista chamada 'list' em uma 
			   STREAM API.

	3- .filter(nome -> nome.startsWith("Anderson")) : 
		Utilizamos o método 'filter()'. Vai filtrar todos os 
		elementos que começar com(startsWith) 'Anderson'.
		* 'nome -> nome...' é só um nome que vamos dar para cada
		elemento.

	4- .toList(): Transformei a 'list' em uma LISTA novamente.


   * .map() :

	ex.: List<String> Andersons = list.stream()
		.map(String::toUpperCase).toList();

	EXPLICAÇÃO:

	1- List<String> Andersons : Criei uma lista do tipo String 
				    chamada 'Andersons';
	
	2- list.stream() : transformei a lista chamada 'list' em uma 
			   STREAM API.

	3- .map(String::toUpperCase): Transforma CADA ELEMENTO String
				      da lista em MAIUSCULAS(UpperCase).

	4- .toList(): Transformei a 'list' em uma LISTA novamente.



   * .reduce() :

	ex.: List<Integer> numeros = new ArrayList<>();
        	numeros.add(1);
        	...
        	numeros.add(5);

	     int soma = numeros.stream()
                .reduce(0, Integer::sum);

	EXPLICAÇÃO:

	1- Criei uma lista de inteiros 'numeros' que recebeu valores de 
	   1 à 5;

	2- int soma : Criei uma variavel chamada 'soma';

	3- numeros.stream() : Transformei a lista chamada 'numeros' em 
			      uma STREAM API.

	4- .reduce(0, Integer::sum) : Inicia a operação em 0.
				      Pega CADA ELEMENTO Inteiro(Integer)
				      e soma(sum).



DICAS PARA RESOLUÇÃO DE PROBLEMAS

* Para PEGAR MAIS DE UM DADO EM UMA LISTA de objetos com um .map() 
  em um .stream():

1- Criamos uma lista com vários objetos dentro, utilizando uma classe
   "Contato"(Já com atributos, construtor, getters e toString):

	ex.: ArrayList<Contato> contatos = new ArrayList<>();
             contatos.add(new Contato("Anderson Bernardo", "9999-9999",
		 "Anderson@hotmail.com", createdAt, updatedAt ));
             contatos.add(new Contato("Andre Bruno", "9899-9899",
		 "Andre@hotmail.com", createdAt, updatedAt ));
             contatos.add(new Contato("Juan Bernardo", "8899-8899", 
		"Juan@hotmail.com", createdAt, updatedAt ));
 

2- Criamos uma nova classe 'NomeEmail' para pegar apenas o nome e o 
   email em cada objeto:

	ex.: public class NomeEmail {
    	 	public String nome;
    		public String email;

    		public NomeEmail(String nome, String email){
        		this.nome = nome;
        		this.email = email;
    		}

    		public String getNome(){
        		return nome;
    		}
   		public String getEmail(){
        		return email;
    		}

    		public String toString(){
        		return nome + " -> " + email;
    		}
	     }


3- Agora criamos uma lista do tipo <NomeEmail> que receberá um '.stream'
   e fazemos um '.map' para mapear toda a lista que criamos 
   anteriormente:

	ex.: List<NomeEmail> lista1 = contatos.stream()
                .map(contato -> new NomeEmail(contato.getNome(), 
		contato.getEmail())).toList();

	* EXPLICAÇÃO:

		1- List<NomeEmail> lista1 : Criamos uma lista do tipo
				'NomeEmail' chamada 'lista1';

		2- contatos.stream() : Criamos um '.stream' com a lista
				  'contatos' que criamos anteriormente;

		3- .map(contato -> new NomeEmail(...) : 
			Criamos um '.map' para mapear cada objeto 
			dentro da lista 'contatos'(contato) criamos um
			novo objeto do tipo 'NomeEmail'(new NomeEmail);

		4- (contato.getNome(), contato.getEmail()): 
			Como cada objeto do tipo 'NomeEmail' precisa de 
			2 parâmetros(nome, email). Pegamos o nome e email
			com os metodos 'getNome' e 'getEmail' da classe 
			'Contato';

		5- .toList() : Agora transformamos o '.stream()' em 
			       LISTA novamente com o '.toList()'.


4- Para mostrar o resultado da lista de tipo 'NomeEmail', usamos um 
   'For-each' especifico para listas:
	
	ex.: for(NomeEmail contato : lista1){
            	System.out.println(contato);
             }

	OBS.: O 'For-each' busca automaticamente o método 'toString' da
	      classe 'NomeEmail' e exibe o resultado de acordo com ela.
	      (Neste caso)



PARA FILTRAR(.filter) DADOS DE UMA LISTA QUE INICIEM COM A LETRA "A":

	ex.:  List<String> lista2 = contatos.stream()
                .filter(contato -> contato.getNome().startsWith("A"))
                .toList();

	* EXPLICAÇÃO:

		1- List<String> lista2 : Cria uma lista do tipo String
				chamada 'lista2';
	
		2- contatos.stream() : Transforma a lista 'contatos' em 
				um '.stream()';
		
		3- .filter(contato -> contato.getNome().startsWith("A")):
			Filtra(.filter) cada contato da lista 'contatos',
			pegando o NOME(getNome()) e utiliza o método
			'startsWith()' para verificar se o NOME do 
			contato inicia com a letra 'A';

	OBS.: O método 'startsWith()' só retorna com STRING, então é 
	      necessário que utilizemos um dado do tipo 'String'. Neste
	      caso foi com o método 'getNome' que retorna a 'String nome'. 

